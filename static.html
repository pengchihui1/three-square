<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>threejs-basic-geometry</title>
    <style>
        body{
            font-family: Monospace;
            background: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>

<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.124/build/three.module.js';
  import { GUI } from 'https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/libs/dat.gui.module.js';
  import Stats from 'https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/libs/stats.module.js';
  import { CinematicCamera } from 'https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/cameras/CinematicCamera.js';
   
    var camera, scene, renderer,raycaster,container,stats;
   var pointer;
    let num = 0;
    const mouse = new THREE.Vector2();
	let INTERSECTED;//當前點擊對象
    main();
    // render();
    animate();

    //主函数
    function main(){
        //添加一个div元素
        container = document.createElement('div')
        document.body.appendChild(container);

        stats = new Stats();
	    document.body.appendChild( stats.dom );

        scene = new THREE.Scene();//创建一个新场景
        scene.background = new THREE.Color( 0xf0f0f0 );

        //添加一个透视相机
        camera = new THREE.PerspectiveCamera(30,window.innerWidth/window.innerHeight, 1, 400);
        camera.position.set(100, 200, 100);//设置相机位置
        camera.lookAt(new THREE.Vector3(0,0,0));//让相机指向原点
        //渲染

        // var axes = new THREE.AxisHelper(100);//参数设置了三条轴线的长度
        // scene.add(axes);

        raycaster = new THREE.Raycaster();//3d世界鼠標選中物體獲取器
        pointer = new THREE.Vector2();//二维向量

        //antialias:true增加抗锯齿效果
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setClearColor(new THREE.Color(0x000000));//设置窗口背景颜色为黑
        renderer.setSize(window.innerWidth, window.innerHeight);//设置窗口尺寸
        //将renderer关联到container，这个过程类似于获取canvas元素
        container.appendChild(renderer.domElement);
        //给场景添加光源
        //自然光
        var ambientLight = new THREE.AmbientLight( 0x606060 );
        scene.add( ambientLight );
        //平行光源
        var directionalLight = new THREE.DirectionalLight( 0xffffff );
        directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
        scene.add( directionalLight );
        renderer.domElement.addEventListener('click', onClick, false);

        renderer.domElement.addEventListener( 'pointermove', onPointerMove );

        plane();
        cube();
        // sphere();
        // cylinder();
    }

    //创建一个平面
    function plane(){
      // 创建一个圆形平面，半径20，圆周方向细分数30
      var plane = new THREE.CircleGeometry(20,30)
      var material = new THREE.MeshPhongMaterial({
            color: 0x999999,
            // 矩形平面网格模型默认单面显示，可以设置side属性值为THREE.DoubleSide双面显示
            side: THREE.DoubleSide,
            // visible: false
        });
        var mesh = new THREE.Mesh(plane, material);
        mesh.name=`plane`
        mesh.rotation.x = -0.5 * Math.PI;//将平面绕X轴逆时针旋转90度
        mesh.position.y = -10;

        scene.add(mesh);//将平面添加到场景中
  
        const gridHelper = new THREE.GridHelper( 100, 20 );
        scene.add( gridHelper );

    }

    //创建一个立方体
    function cube(){
        for(var i=0;i<3;i++){
            var cubeGeo = new THREE.CubeGeometry(10, 10, 10, 1, 1, 1);//创建立方体
            var cubeMat = new THREE.MeshLambertMaterial({//创建材料
                color: Math.random() * 0xffffff,
                wireframe:false,
            });

            const randomPositon=[
                Math.floor(Math.random() * 20+17.5),
                Math.floor(Math.random() * -20-17.5),
            ]
            // console.log(randomPositon[Math.floor(Math.random() *2)])
            // console.log(randomPositon[Math.floor(Math.random() * 2)])
            var cubeMesh = new THREE.Mesh(cubeGeo, cubeMat);//创建立方体网格模型
            cubeMesh.position.set(randomPositon[Math.floor(Math.random() *2)],  0,randomPositon[Math.floor(Math.random() *2)]);//设置立方体的坐标  x z
            cubeMesh.name=`cube${i+1}`//設置模型名稱
            scene.add(cubeMesh);//将立方体添加到场景中
        }
    }
  
    //创建一个球
    function sphere(){
        var sphereGeo = new THREE.SphereGeometry(16, 40, 40);//创建球体
        var sphereMat = new THREE.MeshLambertMaterial({//创建材料
            color:0x0000FF,
            wireframe:false
        });
        var sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);//创建球体网格模型
        sphereMesh.position.set(-25, 10, 0);//设置球的坐标
        scene.add(sphereMesh);//将球体添加到场景
    }

    //创建圆柱体
    function cylinder(){
        //创建圆柱体
        var cylinderGeo = new THREE.CylinderGeometry(15, 15 ,40 ,40 ,40);
        var cylinderMat = new THREE.MeshLambertMaterial({//创建材料
            color:0xFF6600,
            wireframe:false
        });
        //创建圆柱体网格模型
        var cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
        cylinderMesh.position.set(0, 20, -40);//设置圆柱坐标
        scene.add(cylinderMesh);//向场景添加圆柱体
    }
    
    //渲染
    function render(){
        renderer.render(scene, camera);
    }
    
    // 點擊事件
    function onClick( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        // 获取鼠标点击的3D模型
        raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects( scene.children, true );
    
        if ( intersects.length > 0 ) {
             // 點擊到3D內容
            const object = intersects[0].object;
            remove(object)
        }
    }

    // 移除事件
    function remove(object){
        console.log(object)
        switch(object?.name){
            case "cube1":
                scene.remove(object)
                num++;
                break;
            case "cube2":
                scene.remove(object)
                num++;
                break;
            case "cube3":
                scene.remove(object)
                num++;
                break;
        }
        //   點擊數量夠了重新產生方塊
        if(num>=3){
            cube();
            num=0
        }
    }

    function animate() {
        requestAnimationFrame( animate, renderer.domElement );
        render();
        stats.update();
    }
 

    function onPointerMove(event) {
        pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
        raycaster.setFromCamera( pointer, camera );
        const intersects = raycaster.intersectObjects( scene.children, false );
            if ( intersects.length > 0 ) {
                const intersect = intersects[0];
                render();
            }
        }
</script>
</body>
</html>